/**
 *  Copyright (c) 2025
 *  @Version : 1.0.0
 *  @Author  : https://salarizadi.ir
 */
!function(t,e){"function"==typeof define&&define.amd?define([],e):"object"==typeof module&&module.exports?module.exports=e():t.VertexDB=e()}("undefined"!=typeof self?self:this,(function(){"use strict";class t{constructor(t={}){this._tables=new Map,this._whereConditions=[],this._operator="AND",this._orderBy=null,this._limit=null,this._offset=0,this._searchConditions=[],this._relationships=new Map,this._logger=t.logging||!1,this._timestamps=t.timestamps||!1,this._softDelete=t.softDelete||!1,this._lastError=null}setLogging(t){return this._logger=t,this}_log(t,e){this._logger&&console.log(`[${(new Date).toISOString()}] ${t}:`,e)}setTable(t,e=[],s=null){if(!Array.isArray(e))throw new Error("Data must be an array");return s&&this._validateSchema(e,s),this._timestamps&&(e=e.map((t=>({...t,created_at:t.created_at||(new Date).toISOString(),updated_at:t.updated_at||(new Date).toISOString()})))),this._tables.set(t,e),this._log("setTable",{tableName:t,rowCount:e.length}),this}createTable(t,e=null){if(this._tables.has(t))throw new Error(`Table '${t}' already exists`);return this._tables.set(t,[]),e&&(this._schemas=this._schemas||new Map,this._schemas.set(t,e)),this._log("createTable",{tableName:t,hasSchema:!!e}),this}dropTable(t){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);if(this._tables.delete(t),this._schemas&&this._schemas.delete(t),this._relationships&&this._relationships.delete(t),this._indexes)for(const e of this._indexes.keys())e.startsWith(`${t}:`)&&this._indexes.delete(e);return this._log("dropTable",{tableName:t}),this}exists(t){return this.count(t)>0}addColumn(t,e,s=null){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);const r=this._tables.get(t).map((t=>({...t,[e]:s})));return this._tables.set(t,r),this._log("addColumn",{tableName:t,columnName:e}),this}dropColumn(t,e){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);const s=this._tables.get(t).map((t=>{const{[e]:s,...r}=t;return r}));return this._tables.set(t,s),this._log("dropColumn",{tableName:t,columnName:e}),this}setRelation(t,e,s,r){return this._relationships.has(t)||this._relationships.set(t,[]),this._relationships.get(t).push({table:e,type:s,foreignKey:r}),this}get(t){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);let e=[...this._tables.get(t)];return this._softDelete&&(e=e.filter((t=>!t.deleted_at))),e=this._applyConditions(e),this._resetConditions(),this._log("get",{tableName:t,resultCount:e.length}),e}getOne(t){const e=this.get(t);return e.length>0?e[0]:null}search(t){return this._searchConditions=Object.entries(t),this}orderBy(t,e="ASC"){return this._orderBy={column:t,direction:e.toUpperCase()},this}limit(t,e=0){return this._limit=t,this._offset=e,this}whereOperator(t,e,s){return this._whereConditions.push({field:t,operator:e,value:s}),this}where(t,e,s="AND"){return this._whereConditions.push({field:t,value:e,operator:s}),this}orWhere(t,e){return this.where(t,e,"OR")}whereIn(t,e){if(!Array.isArray(e))throw new Error("Values must be an array");return this._whereConditions.push({field:t,operator:"IN",value:e}),this}whereLike(t,e){return this._whereConditions.push({field:t,operator:"LIKE",value:e}),this}count(t){return this.get(t).length}distinct(t,e){const s=this.get(t);return[...new Set(s.map((t=>t[e])))]}avg(t,e){const s=this.get(t);return 0===s.length?0:s.reduce(((t,s)=>t+(s[e]||0)),0)/s.length}sum(t,e){return this.get(t).reduce(((t,s)=>t+(s[e]||0)),0)}min(t,e){const s=this.get(t);return 0===s.length?null:Math.min(...s.map((t=>t[e])))}max(t,e){const s=this.get(t);return 0===s.length?null:Math.max(...s.map((t=>t[e])))}groupBy(t,e){return this.get(t).reduce(((t,s)=>{const r=s[e];return t[r]||(t[r]=[]),t[r].push(s),t}),{})}_applyConditions(t){let e=[...t];return this._whereConditions.length>0&&(e=e.filter((t=>this._whereConditions.every((e=>{switch(e.operator){case"IN":return e.value.includes(t[e.field]);case"LIKE":return String(t[e.field]).includes(e.value.replace(/%/g,""));case">":return t[e.field]>e.value;case"<":return t[e.field]<e.value;case">=":return t[e.field]>=e.value;case"<=":return t[e.field]<=e.value;case"!=":return t[e.field]!==e.value;default:return t[e.field]===e.value}}))))),this._searchConditions.length>0&&(e=e.filter((t=>this._searchConditions.some((([e,s])=>String(t[e]).toLowerCase().includes(String(s).toLowerCase())))))),this._orderBy&&e.sort(((t,e)=>"ASC"===this._orderBy.direction?t[this._orderBy.column]>e[this._orderBy.column]?1:-1:t[this._orderBy.column]<e[this._orderBy.column]?1:-1)),null!==this._limit&&(e=e.slice(this._offset,this._offset+this._limit)),e}insert(t,e){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);const s=this._tables.get(t),r={...e};return"AUTO_INCREMENT"===e.id&&(r.id=this._getNextId(t)),this._lastInsertId=r.id,this._timestamps&&(r.created_at=(new Date).toISOString(),r.updated_at=(new Date).toISOString()),s.push(r),this._log("insert",{tableName:t,data:r}),this}getLastInsertId(){return this._lastInsertId?(this._log("getLastInsertId",{id:this._lastInsertId}),this._lastInsertId):null}bulkInsert(t,e){return e.forEach((e=>this.insert(t,e))),this}update(t,e){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);const s={...e};this._timestamps&&(s.updated_at=(new Date).toISOString());const r=this._tables.get(t).map((t=>this._whereConditions.every((e=>t[e.field]===e.value))?{...t,...s}:t));return this._tables.set(t,r),this._log("update",{tableName:t,data:s}),this._resetConditions(),this}delete(t){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);const e=this._tables.get(t);if(this._softDelete){const s=e.map((t=>this._whereConditions.every((e=>t[e.field]===e.value))?{...t,deleted_at:(new Date).toISOString()}:t));this._tables.set(t,s)}else{const s=e.filter((t=>!this._whereConditions.every((e=>t[e.field]===e.value))));this._tables.set(t,s)}return this._log("delete",{tableName:t,softDelete:this._softDelete}),this._resetConditions(),this}toJSON(t){const e=this.get(t);return JSON.stringify(e,null,2)}fromJSON(t,e){try{const s=JSON.parse(e);return this.setTable(t,s),this}catch(t){throw this._lastError=t,new Error("Invalid JSON data")}}getLastError(){return this._lastError}_getCurrentTimestamp(){return(new Date).toISOString().slice(0,19).replace("T"," ")}_validateSchema(t,e){for(const s of t)for(const[t,r]of Object.entries(e)){if(r.required&&(void 0===s[t]||null===s[t]))throw new Error(`Field '${t}' is required`);if(r.type&&typeof s[t]!==r.type)throw new Error(`Field '${t}' must be of type ${r.type}`);if(r.min&&s[t]<r.min)throw new Error(`Field '${t}' must be at least ${r.min}`);if(r.max&&s[t]>r.max)throw new Error(`Field '${t}' must be at most ${r.max}`);if(r.length&&String(s[t]).length!==r.length)throw new Error(`Field '${t}' must be exactly ${r.length} characters long`);if(r.pattern&&!r.pattern.test(String(s[t])))throw new Error(`Field '${t}' does not match required pattern`)}}backup(){const t={timestamp:this._getCurrentTimestamp(),data:{},metadata:{tables:[],relationships:{}}};for(const[e,s]of this._tables.entries())t.data[e]=s,t.metadata.tables.push({name:e,count:s.length});return t.metadata.relationships=Object.fromEntries(this._relationships),t}restore(t){try{return this._tables=new Map(Object.entries(t.data)),this._relationships=new Map(Object.entries(t.metadata.relationships)),this._log("restore",{timestamp:t.timestamp}),this}catch(t){throw this._lastError=t,new Error("Invalid backup data")}}join(t,e,s,r){const i=this._tables.get(t),a=this._tables.get(e);if(!i||!a)throw new Error("One or both tables do not exist");return i.map((i=>{const n=a.find((t=>t[r]===i[s]));if(n){const s={};return Object.keys(i).forEach((e=>{s[`${t}_${e}`]=i[e]})),Object.keys(n).forEach((t=>{s[`${e}_${t}`]=n[t]})),s}return i}))}transaction(t){const e=this.backup();try{return t(this),this._log("transaction",{status:"committed"}),this}catch(t){throw this.restore(e),this._log("transaction",{status:"rollback",error:t.message}),t}}createIndex(t,e){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);this._indexes||(this._indexes=new Map);const s=this._tables.get(t),r=new Map;for(const t of s){const s=e.map((e=>t[e])).join("|");r.has(s)||r.set(s,[]),r.get(s).push(t)}return this._indexes.set(`${t}:${e.join("+")}`,r),this._log("createIndex",{tableName:t,columns:e}),this}getStats(){const t={tables:{},totalRecords:0,lastModified:this._getCurrentTimestamp(),indexes:[],relationships:[]};for(const[e,s]of this._tables.entries())t.tables[e]={count:s.length,columns:s.length>0?Object.keys(s[0]).length:0},t.totalRecords+=s.length;return this._indexes&&(t.indexes=Array.from(this._indexes.keys())),this._relationships&&(t.relationships=Array.from(this._relationships.entries())),t}paginate(t,e=1,s=10){const r=this.count(t),i=Math.ceil(r/s),a=(e-1)*s;return{data:this.limit(s,a).get(t),pagination:{total:r,perPage:s,currentPage:e,totalPages:i,hasNextPage:e<i,hasPrevPage:e>1}}}raw(t,e){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);return this._tables.get(t).filter(e)}truncate(t){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);return this._tables.set(t,[]),this._log("truncate",{tableName:t}),this}getSchema(t){return this._schemas?this._schemas.get(t):null}updateSchema(t,e){if(!this._tables.has(t))throw new Error(`Table '${t}' does not exist`);this._schemas=this._schemas||new Map,this._schemas.set(t,e);const s=this._tables.get(t);return this._validateSchema(s,e),this._log("updateSchema",{tableName:t}),this}_getNextId(t){const e=this._tables.get(t);if(!e||0===e.length)return 1;return Math.max(...e.map((t=>parseInt(t.id)||0)))+1}_resetConditions(){this._whereConditions=[],this._operator="AND",this._orderBy=null,this._limit=null,this._offset=0,this._searchConditions=[]}}return t.AUTO_INCREMENT="AUTO_INCREMENT",t.OPERATORS={EQ:"=",GT:">",LT:"<",GTE:">=",LTE:"<=",NEQ:"!=",LIKE:"LIKE",IN:"IN"},t}));